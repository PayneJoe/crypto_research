def gcd(x, N):
    assert(x < N)
    
    (A, B) = (N, x)
    (Ua, Ub) = (0, 1)
    (Va, Vb) = (1, 0)
    i = 0
    while B:
        q = A // B
        (A, B) = (B, A % B)
        (Ua, Ub) = (Ub, Ua + q * Ub)
        (Va, Vb) = (Vb, Va + q * Vb)
        i += 1
    r, u, v = A, Ua, Va
    
    return r, u, i % 2 == 0

########################################################### parameter polynomials
x = ZZ['x'].gen()
## prime field, p
px = 36 * x^4 + 36 * x^3 + 24 * x^2 + 6 * x + 1
## largest prime facotr, r
rx = 36 * x^4 + 36 * x^3 + 18 * x^2 + 6 * x + 1
## trace of frobenius, t
tx = 6 * x^2 + 1
## cyclotomic group of 12-extension degree, phi_12
phi_12 = px^4 - px^2 + 1
## power final exponentiation, h
hx = (px^12 - 1) // rx
## optimal lambda in miller loop, lambda
lambdax = 6 * x + 2 + px - px^2 + px^3
## multiples of r, m
mx = lambdax // rx
#########################################################

## constant parameters
x = 4965661367192848881
# x = 6518589491078791937
p, r, h, lamb, m = px(x), rx(x), hx(x), lambdax(x), mx(x)
d = gcd(m, h)[0]
mm = m // d

########################################################## tower field
## Fp2 = Fp[u] / X^2 - alpha, where alpha = -1
## Fp6 = Fp2[v] /X^3 - beta, where beta = u + 9
## Fp12 = Fp6[w] / X^2 - gamma, where gamma = v
## full extension field, Fp12 = Fp[w] / X^12 - 18 * X^6 + 82 

Fp = GF(p)
X = Fp['X'].gen()
alpha = Fp(-1)

pol2 = X^2 - alpha
Fp2 = Fp.extension(pol2, 'u')
u = Fp2.gen()
beta = u + 9

pol6 = X^3 - beta
Fp6 = Fp2.extension(pol6, 'v')

pol12 = X^12 - 18 * X^6 + 82
Fp12 = Fp.extension(pol12, 'y')
###########################################################

########################################################### G1
a, b = Fp(0), Fp(3)
G1 = EllipticCurve(Fp, [a, b])
assert(G1.order() % r == 0)
co_g1 = G1.order() // r
g1 = G1.random_element() * co_g1
assert(g1 * r == G1(0))
###########################################################
print('[##G1]: cofactor = {}, \n generator = {}\n'.format(co_g1, g1))

########################################################### G2
beta_t = beta
if EllipticCurve(Fp2, [a, b * beta_t]).order() % r != 0:
    # beta_t = beta ** 5
    # print('[!] beta_t = beta^5 \n')
    beta_t = 1 / beta
G2 = EllipticCurve(Fp2, [a, b * beta_t])
assert(G2.order() % r == 0)
co_g2 = G2.order() // r
g2 = G2.random_element() * co_g2
assert(g2 * r == G2(0))
###########################################################
print('[##G2]: cofactor = {}, \n generator = {}\n'.format(co_g2, g2))

g1 = G1(
    Fp(19491323635986486980056165026003970884581302300479364565163758691834883767296),
    Fp(2503817206389621232991390790939417031444960302945150474681637705185779211401)
)

g2 = G2(
    Fp2(
        [10022529265301880767558967801827554994678953177337994173174782310334418209951,
        11403269112307582471523194844678173363615200121780745962919905543513926078845]
    ),
    Fp2(
        [14403937293889182757621054345090826401263455856569175761852807173588543872656,
        7417909083002664933410862546938954664060641619680344911439335935535164894254]
    )
)
assert(g2 * r == G2(0))

#print(r)
#print(len(bin(p)[2:]))
print(g2 * 123432)

sys.exit(1)

## coefficients for one time of frobenius map
beta_pi_1 = [beta ** (i * ((p - 1) // 6)) for i in range(1, 6)]
## coefficients for two times of frobenius map
beta_pi_2 = [beta ** (i * (((p ** 2) - 1) // 6)) for i in range(1, 6)]
## coefficients for three times of frobenius map
beta_pi_3 = [beta ** (i * (((p ** 3) - 1) // 6)) for i in range(1, 6)]

def phi_1(point):
    return G2(
        point.xy()[0].conjugate() * beta_pi_1[1],
        point.xy()[1].conjugate() * beta_pi_1[2],
    )

def phi_2(point):
    return G2(
        point.xy()[0] * beta_pi_2[1],
        point.xy()[1] * beta_pi_2[2],
    )

def phi_3(point):
    return G2(
        point.xy()[0].conjugate() * beta_pi_3[1],
        point.xy()[1].conjugate() * beta_pi_3[2],
    )

# a1 = Fp6(
#     [
#         Fp2([6088367594887948535198101789153688110714923513495884874741586903581837863364, 23466515924608171744806590732715972474769585833411798166089211259921691975760]),
#         Fp2([35458960771831016198471345133586123730941499514893339573790653174056055513216, 9672792859887369963939184684155318091540048810685988613867328450643225989461]),
#         Fp2([10653912108617570699532580981793323610117235430906220392770520198470714341272, 43555124918671301604266790937424100984583784933076737272356409657018569022636]),
#     ]
# )
# a0 = Fp6(
#     [
#         Fp2([25069846482253735217361664279916398731130585313648849382991912561140139246044, 4547933636572214591644003995784460975218011638418727547277320979265733568780]),
#         Fp2([59001345742921222150713233420681823336079501206795650030874180190631159580022, 25026428680401797149355734042459075662755785073578959086620381896415333115328]),
#         Fp2([50717508110767228586900749002958939130195342178521824782491670804101845666992, 31782757577693053437856971330013743844251359258834407582404424985665621088740]),
#     ]
# )
# b1 = Fp6(
#     [
#         Fp2([40540300980510194437639073079056166610810621046994545935952604507384545995675, 55054225481173335329204219894833971447991711418356493970567411758287587361358]),
#         Fp2([12233959460052355113664159072402819179598024505250017038129086328174898544086, 4445431583094371568581130788005804004447781159899560828576769274870747406528]),
#         Fp2([59969622452432522951722915075792868998113567193732569969818689175044235413503, 28913219250881447942030181938495959559894938028691288713317211622627956468096]),
#     ]
# )
# b0 = Fp6(
#     [
#         Fp2([60209313820782792482072445719490384806781143265484040830786525901756529089812, 59316335628912534032548203093313109467051085619214366538401668058629723767320]),
#         Fp2([31836233561563629046987860032314290015515504950528816602431588456527592771499, 60891524000391813582359982279728619461141511718303223004134393543850673940700]),
#         Fp2([13885229862651899315704668744254641400421851415715047323775553296633815548128, 10643605271812249633906257090996115530468546906038986449419307769229904165421]),
#     ]
# )
a0 = Fp6(
    [
        Fp2([19482641706064118683666785877159816774833750798416884741599879590406746710229, 0]),
        Fp2([0, 0]),
        Fp2([50907584953896980726214758383059745758608967402376068492169291309170705561063, 34828782555959400749089873727311924436065246867786464483939282510422038828023])
    ]
)
a1 = Fp6(
    [
        Fp2([0, 0]),
        Fp2([12209634622754641969054606663103921359299723226413609383381251071991033840971, 15843156042020513199926158630706144859076300417832337935171017027294868376203]),
        Fp2([0, 0])
    ]
)
b0 = Fp6(
    [
        Fp2([37152507632483591484435791911354797337571904428358231246265173998464956873438, 0]),
        Fp2([0, 0]),
        Fp2([7959959503469563391699279464233690318175839734394227536101783192665624537918, 19744856206700437860953523711822183234635231116373081271456856943097731729858])
    ]
)
b1 = Fp6(
    [
        Fp2([0, 0]),
        Fp2([9146642495220243917512705633605220321294157277065762527559792039231187113908, 25674720514203944480604688097299722111955882161583829277089949012182826810769]),
        Fp2([0, 0])
    ]
)
c0 = a0 * b0 + a1 * b1 * Fp6.gen()
c1 = a0 * b1 + a1 * b0
# print(c1)
# print(c0)
print(a1 * b1)
# from sage.schemes.elliptic_curves.hom_frobenius import EllipticCurveHom_frobenius

# phi_1 = EllipticCurveHom_frobenius(G2, 1)
# phi_2 = EllipticCurveHom_frobenius(G2, 2)
# phi_3 = EllipticCurveHom_frobenius(G2, 3)

# a = -(g2 * 3)
# print(a)
# print('================')
# print(phi_1(a))
# assert(phi_1(a) == a * p)
# print('-------------')
# print(phi_2(a))
# assert(phi_2(a) == a * p^2)
# print('-------------')
# print(phi_3(a))
# assert(phi_3(a) == a * p^3)

print(beta_pi_2[2] == Fp2(-1))

## check
def double(x, y, z):
    A = x ** 2
    print('A = {}\n\n'.format(A))
    B = y ** 2
    print('B = {}\n\n'.format(B))
    C = B ** 2
    print('C = {}\n\n'.format(B))

    t = x + B
    t = t ** 2

    D = (t - A - C)
    D = D * 2

    E = A * 2 + A
    F = E ** 2

    C8 = C * 8

    c_x = (F - D * 2)
    c_y = (E * (D - c_x) - C8)
    c_z = (y * z) * 2

    return c_x, c_y, c_z 

# d = double(g2[0], g2[1], g2[2])
# print(d[0] / d[2]^2, d[1] / d[2]^3)